//Comments are made by 2 slashes

//import files via the `use` keyword
use std;
//import all contents of files via a *
use sys.*;
//importing is similar to rust,so it should be easy to use
use lib.{foo,bar.{ResRetFunc,Vec3 as Point}};

//all code is run inside the main function
fn main(in args : Args) -> ExitCode{
	//mutable variables are made by the `var` keyword,immutable ones are made via the `let`
	var i = 1;
	let b = true;
	let s : StrLit = "Hello world";
	

	//basic math like C type languages
	i += 4;
	i = (i - 1) * 5;

	//however,unlike other languages,you can't negate a numeric variable directly with -,instead use the `Neg` property
	i = i.Neg;
	
	//Supported types
	
//	Ints and UInts like zig
//	Float 16,32,64,80,128
//	Bool
//	Str and StrLit (string literal)
//	Dyn (dynamic object that can change type, similar to programming in dynamically typed languages)
//	Option[T] (a return value that can either be a value or none,is a replacement for null)
//	Result[T,E] (a return value that can either be an value or an error,will explaing handling errors later)
//	Nullable[T] (a value type that can be set to null,this is still being considered)
//	Ptr[T] (a pointer that contains the memory address of a variable)
//	Uniq_Ptr[T]  (a pointer that deletes itself when out of scope)
//	Shrd_Ptr[T] (a pointer that deletes itself when all references to object are gone)
//	VoidPtr (a void pointer)
//	AnyPtr (a pointer for any type)
//	Ref[T] (a reference to a certain object)
//	Evt[Param[P]] (an event type, can take any amount of parameters)
//	RetEvt[Param[P]][Param[R]] (an event type that can return a value)
	

	//If statments and condition checking
	let c : u8 = if b : 'a' else 'b';

	//single booleans can be checked with either the `not` keyword if they aren't a function or value from a struct or with the `Not` property
	if not false and b.Not{
		//Do something
	}
	elif not b{
		//Do something else
	}
	else{
		//Finally do something
	}

	//match statments are similar to rust
	var res = ResRetFunc();
	match res{
		Pass(o) => {
			match o{
				String => //Do something with string,
				Bool => {
					  //Do something with bool, this also shows multiple line support in matches
					},
				_ => nope() // nope is a function that does nothing
			}
		},
		Fail(e) => puts(e) //Print objects via the `puts` functions,if you want a new line use `putsln`
	}

	//use the loop keyword to loop indefinietly
	loop {
		stop; //breaks the loop
		//the keyword `continue` isn't used, `skip` is used instead	
	}

	//while loops
	while false{
		nope();
	}

	//arrays in use, also static functions are called with .
	var names = Array[Str].Create("Brad", "Tyler", "Tracy", "Maria");

	//supported collections are
	
//	Array[T]
//	Vector[T]
//	Tuple[Param[T]]
//	Dict[K,V]
//	Hash[,]
	

	//for loops
	for name in names {
		puts(name);
	}

	//use `Range` function to get a range,if you want inclusion then use `RangeIncl`
	for j in Range(1, 100){
		i += j;
	}
	
	//Collections use colName(x) to access an index,for example
	let arr_val1 = names(0);
	//is the same as
	let arr_val2 = names.Get(1);

	//example of class creation
	let p_var = Point(1,2,3);
	
	//example of pointer creation, this will give an error since raw pointers are only acceptable in unsafe contexts
	let p_ptr = Point.new(2,4,6);
	//use `scope` to create a Unique Pointer or `ref` to create a Shared Pointer,this only works with `new` or heap 
	let i = p_ptr.*;//deref the pointer like zig
	
	return .Success;//returns success
}

//Structs and traits

trait Animal{
   fn make_noise();
}

//Traits can be added via

Dog :: struct {
   	var pup : Bool,
   	
	impl Animal for Dog{
   		fn make_noise(){
   		    puts("Woof!");
   		}
	}
};

Cat :: struct {
   var scratches : Bool
};

impl Animal for Cat{
   fn make_noise(){
	puts("Meow?");
   }
};

impl Cat{
   fn scratch(ref scratchable : Dyn = 1){
	//String concat
	putsln($"Scratched {scratchable}!!!");
   }
;}

Rabbit :: struct[Animal](let chonky: Int) {
	fn make_noise(){
		puts("");
	}
};

